Import: import { JisonParser, JisonParserApi, StateType, SymbolsType, TerminalsType, ProductionsType } from '@ts-jison/parser';

Constructor: |
  export class {{NAME}}Parser extends JisonParser implements JisonParserApi {
      $?: any;
      symbols_: SymbolsType = {{STATE_NAMES}};
      terminals_: TerminalsType = {{TERMINALS}};
      productions_: ProductionsType = {{PRODUCTIONS}};
      table: Array<StateType>;
      defaultActions: {[key:number]: any} = {{DEFAULT_ACTIONS}};
  
      constructor (yy = {}, lexer = new {{NAME}}Lexer(yy)) {
        super(yy, lexer);

        // shorten static method to just `o` for terse STATE_TABLE
        const {{STATE_TABLE_FACTORS}};
        const o = JisonParser.expandParseTable;
        this.table = {{STATE_TABLE}};
      }

      performAction (yytext:string, yyleng:number, yylineno:number, yy:any, yystate:number /* action[1] */, $$:any /* vstack */, _$:any /* lstack */{{PARSE_PARAMS}}): any {
  /* this == yyval */
  {{ACTION_INCLUDE}}          var $0 = $$.length - 1;
          switch (yystate) {
  {{STATE_ACTIONS}}
          }
      }
  }

Export: ''

ParseError: |
  function parseError (str: string, hash: {[key: string]: any}): void {
      if (hash.recoverable) {
          this.trace(str);
      } else {
          var error = new Error(str);
          (<any>error).hash = hash;
          throw error;
      }
  }
