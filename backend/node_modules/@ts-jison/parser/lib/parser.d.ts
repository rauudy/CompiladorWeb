import { JisonLexerApi } from '@ts-jison/lexer';
import { ParseErrorType, ParseErrorHashType } from '@ts-jison/common';
export interface StateType {
    [key: number]: number | number[];
}
export interface JisonParserApi {
    trace: (str?: string) => void;
    performAction: (yytext: string, yyleng: number, yylineno: number, yy: any, yystate: any, $$: any, _$: any) => any;
    parseError: ParseErrorType;
    parse: (input: string) => void;
}
export type SymbolsType = {
    [key: string]: number;
};
export type TerminalsType = {
    [key: number]: string;
};
export type ProductionsType = Array<number | number[]>;
export declare abstract class JisonParser {
    yy: any;
    lexer?: JisonLexerApi | undefined;
    constructor(yy?: any, lexer?: JisonLexerApi | undefined);
    trace(str?: string): any;
    abstract symbols_: SymbolsType;
    abstract terminals_: TerminalsType;
    abstract productions_: ProductionsType;
    abstract table: Array<StateType>;
    abstract defaultActions: {
        [key: number]: any;
    };
    abstract performAction(yytext: string, yyleng: number, yylineno: number, yy: any, yystate: number, $$: any, _$: any): any;
    parseError(str: string, hash: ParseErrorHashType): void;
    parse(input: string, yy?: any): any;
    static expandParseTable(k: number[], v: number[], o?: StateType): StateType;
}
//# sourceMappingURL=parser.d.ts.map